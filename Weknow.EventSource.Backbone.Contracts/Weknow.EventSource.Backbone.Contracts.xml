<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Weknow.EventSource.Backbone.Contracts</name>
    </assembly>
    <members>
        <member name="T:Weknow.EventSource.Backbone.Ackable`1">
            <summary>
            Represent acknowledge-able instance.
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.Ackable`1.#ctor">
            <summary>
            Prevents a default instance.
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.Ackable`1.#ctor(`0,Weknow.EventSource.Backbone.IAck)">
            <summary>
            Initializes a new instance        /// </summary>
            <param name="item">The item.</param>
            <param name="ack">The acknowledge handle (callback).</param>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Ackable`1.Item">
            <summary>
            Gets the item data.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Ackable`1.Ack">
            <summary>
            Send Acknowledge (some queue type [like event sourcing] 
            keep the item in the queue until it processed,
            the acknowledge will notify it that it can be delete).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Weknow.EventSource.Backbone.IAck">
            <summary>
            Represent acknowledge trigger which will 
            set the status on the event as done or release 
            it for re-consuming.
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.IAck.RevokeAfter(System.TimeSpan)">
            <summary>
            Revokes the operation if not completed after a duration.
            </summary>
            <param name="timeout">The timeout.</param>
        </member>
        <member name="T:Weknow.EventSource.Backbone.Announcement">
            <summary>
            Non-generics form of announcement representation,
            used to transfer data via channels.
            </summary>
        </member>
        <member name="F:Weknow.EventSource.Backbone.Announcement.Empty">
            <summary>
            The empty
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.Announcement.#ctor">
            <summary>
            Only for serialization support.
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.Announcement.#ctor(Weknow.EventSource.Backbone.Metadata,System.Collections.Immutable.ImmutableDictionary{System.String,System.ReadOnlyMemory{System.Byte}})">
            <summary>
            Initializes a new instance        /// </summary>
            <param name="metadata">The metadata.</param>
            <param name="segments">The segments.</param>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Announcement.Metadata">
            <summary>
            Gets or sets the metadata.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Announcement.Segments">
            <summary>
            Gets or sets the segments.
            Segmentation is done at the sending side, 
            by Segmentation provider which can be register in order
            to segments different parts of the messages.
            The motivation of segmentation can come from regulation like
            GDPR (right to erasure: https://gdpr-info.eu/).
            </summary>
            <example>
            Segmentation provider can split the message 
            into personal and non-personal segments.
            </example>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Announcement.InterceptedData">
            <summary>
            Gets or sets the mapping of data which 
            was created by interceptors on the send side
            and should be evaluate by the interceptor at consume side.
            </summary>
        </member>
        <member name="T:Weknow.EventSource.Backbone.Metadata">
            <summary>
            <![CDATA[Represent metadata of announcement (event).
            This information is available via Metadata.Current 
            as long as the async-context exists.
            Recommended to materialize it before sending to queue and
            use Metadata.SetContext(metadata)
            </summary>
            <remarks>
            Unlike the segments, this part can be flow with
            message & will be set as async-context.]]> 
            </summary>
        </member>
        <member name="F:Weknow.EventSource.Backbone.Metadata.Empty">
            <summary>
            The empty
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.Metadata.#ctor">
            <summary>
            Only for serialization support.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Metadata.MessageId">
            <summary>
            The message identifier.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Metadata.Retries">
            <summary>
            Gets the retries time of re-consuming the message.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Metadata.ProducedAt">
            <summary>
            The sending time.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.Metadata.Duration">
            <summary>
            Calculation of Duration since produce time
            </summary>
        </member>
        <member name="T:Weknow.EventSource.Backbone.ShardMetadata">
            <summary>
            Represent metadata of message (command / event) metadata of
            a communication channel (Pub/Sub, Event Source, REST, GraphQL).
            It represent the operation's intent or represent event.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.EventSourceConsumerOptions.BatchSize">
            <summary>
            Gets the max batch size of reading messages per shard.
            The framework won't proceed to the next batch until all messages
            in the batch complete (or timeout when it set to acknowledge on timeout).
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.EventSourceConsumerOptions.TimeoutBehavior">
            <summary>
            Define the behavior of the framework on timeout.
            </summary>
        </member>
        <member name="P:Weknow.EventSource.Backbone.EventSourceConsumerOptions.MaxDegreeOfParallelism">
            <summary>
            Reduce the maximum concurrency level.
            </summary>
        </member>
        <member name="T:Weknow.EventSource.Backbone.IDataSerializer">
            <summary>
            Enable to replace the default serialization
            </summary>
        </member>
        <member name="M:Weknow.EventSource.Backbone.IDataSerializer.Serialize``1(``0)">
            <summary>
            Serialize item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.EventSource.Backbone.IDataSerializer.Deserialize``1(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Deserialize  data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="serializedData">The serialized data.</param>
            <returns></returns>
        </member>
        <member name="P:Weknow.EventSource.Backbone.IInterceptorName.InterceptorName">
            <summary>
            Unique name which represent the correlation
            between the producer and consumer interceptor.
            It's recommended to use URL format.
            </summary>
        </member>
        <member name="F:Weknow.EventSource.Backbone.TimeoutBehavior.Ack">
            <summary>
            Will acknowledge the messages on timeout.
            </summary>
        </member>
        <member name="F:Weknow.EventSource.Backbone.TimeoutBehavior.Replay">
            <summary>
            Will replay the messages on timeout.
            </summary>
        </member>
    </members>
</doc>
